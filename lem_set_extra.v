(* Generated by Lem from set_extra.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(******************************************************************************)
(* A library for sets                                                         *)
(*                                                                            *)
(* It mainly follows the Haskell Set-library                                  *)
(******************************************************************************)

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

Require Import lem_bool.
Require Export lem_bool.
Require Import lem_basic_classes.
Require Export lem_basic_classes.
Require Import lem_maybe.
Require Export lem_maybe.
Require Import lem_function.
Require Export lem_function.
Require Import lem_num.
Require Export lem_num.
Require Import lem_list.
Require Export lem_list.
Require Import lem_sorting.
Require Export lem_sorting.
Require Import lem_set.
Require Export lem_set.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition setCompare {a : Type} `{SetType a} `{Ord a}   : set a -> set a -> ordering :=  set_compare_by compare.

Instance x153_SetType{a: Type} `{SetType a}: SetType (set  a):= {
   setElemCompare  :=  set_compare_by setElemCompare
}.

(* [?]: removed value specification. *)

Program Fixpoint leastFixedPointUnbounded {a : Type} `{SetType a}  (f : set a -> set a) (x : set a)  : set a:= 
   let fx  := f x in
   if (set_subset_by setElemCompare fx x) then x
   else leastFixedPointUnbounded f ( (set_union_by setElemCompare fx x)).
