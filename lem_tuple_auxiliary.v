(* Generated by Lem from tuple.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Open Scope nat_scope.
Open Scope string_scope.


Lemmafst_def_lemma:((forallv2 v1,( 
  v1 = (@ fst _ _) (v1, v2) : Prop)): Prop) .

Lemma fst_1 :( ( Bool.eqb((@ fst _ _) (true, false)) true): Prop) . 
Lemma fst_2 :( ( Bool.eqb((@ fst _ _) (false, true)) false): Prop) .
Lemmasnd_def_lemma:((forallv2 v1,( 
  v2 = (@ snd _ _) (v1, v2) : Prop)): Prop) .

Lemma fst_snd:( (forall v,( ((tuple_equal_by (fun x y => x = y) (fun x y => x = y) v ((@ fst _ _) v, (@ snd _ _) v))) : Prop)): Prop) .

Lemma snd_1 :( ( Bool.eqb((@ snd _ _) (true, false)) false): Prop) . 
Lemma snd_2 :( ( Bool.eqb((@ snd _ _) (false, true)) true): Prop) .

Lemma curry_1 :( ( Bool.eqb(prod_curry (
  fun (p : (bool *bool ) % type) => match ( (p) ) with ( (x, y)) => x && y end) true false) false): Prop) .

Lemma curry_uncurry:( (forall f  xy,( prod_uncurry (prod_curry f) xy = f xy : Prop)): Prop) .
Lemma uncurry_curry:( (forall f  x  y,( prod_curry (prod_uncurry f) x y = f x y : Prop)): Prop) .

Lemma uncurry_1 :( ( Bool.eqb(prod_uncurry (fun (x : bool ) (y : bool ) => x && y) (true, false)) false): Prop) . 
Lemmaswap_def_lemma:((forallv2 v1,(((tuple_equal_by (fun x y => x = y) (fun x y => x = y) (v2, v1) ((
  fun (p : (a*b) % type) => match ( (p) ) with ( (v1,  v2)) => (v2, v1) end) (v1, v2)))) : Prop)): Prop) .

Lemma swap_1 :( ( ((tuple_equal_by Bool.eqb Bool.eqb ((
  fun (p : (bool *bool ) % type) =>
    match ( (p) ) with ( (v1,  v2)) => (v2, v1) end) (false, true)) (true, false)))): Prop) .

